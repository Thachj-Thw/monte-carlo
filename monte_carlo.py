# -*- coding: utf-8 -*-
"""Monte_carlo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VVuLz88DUWx9AQXWqc8ZFAHs8ioLchUi

Require neccessary library
"""

# from google.colab import drive
# drive.mount('/content/drive')

# from scipy import random
from numpy import random
import numpy as np
# from numpy import sqrt
# import matplotlib.pyplot as plt
# import csv
# from sklearn.model_selection import train_test_split
# from keras import Sequential
# from keras.layers import Dense
# import tensorflow as tf
# from keras import optimizers
# import pandas as pd
# import keras.models as Model
import time
random.seed(9)

"""Define Gamma function"""

gamma = np.sqrt(np.pi)


"""Define f(t)"""

def f(t, x):
    temp = t/((x-t)**(1/2) * gamma)
    #temp = (t/(np.sqrt(1-t)**5))/((x-t)**(1/2)*gamma)
    #temp = (t/((1+t)**(5/2)))/((x-t)**(1/2)*gamma)
    #temp = (np.sqrt(t)/(t-1))/((x-t)**(1/2)*gamma)
    #temp = (np.e**t)/((x-t)**(1/2)*gamma)
    #temp = (t*np.e**(2*t))/((x-t)**(1/2)*gamma)
    #temp = (np.sin(t))/((x-t)**(1/2)*gamma)
    return temp

"""Define correct(t)"""

def correctFunction(t):
    temp = (4 * t**(3/2))/(3 * gamma)
    #temp = (4*t**(3/2))/(3*np.sqrt(np.pi)*(1-t)**2)
    #temp = (4*t**(3/2))/(3*np.sqrt(np.pi)*(1+t)**2)
    #temp = (np.sqrt(np.pi)*t)/((np.sqrt(t+1))*(1+np.sqrt(t+1)))
    return temp

"""Contruct class for particular integration, plotting and neural network training.

MCIntegration class take 6 arguments:
1.   function f(t)
2.   limit a
3.   limit b
4.   N uniform distribution
5.   step deltaX
6.   number of steps
There are two functions:

1.   getIntegral: calculate particular integration
2.   getDataset: return a set of integration value for plotting and NN training






"""

class MCIntegration:
    def __init__(self, f, a, b, N, dx, data_count):
        self.f = f
        self.a = a
        self.b = b
        self.N = N
        self.dx = float(dx)
        self.n = data_count
        
    def getIntegral(self):
        # O(len(ar))
        ar = np.zeros(self.N)
        for i in range(len(ar)):
            ar[i] = random.uniform(self.a, self.b)
        integral = 0.0 
        for i in ar:
            integral += self.f(i, self.b)
        ans = (self.b - self.a) / float(self.N) * integral
        return ans
    
    def getDataset(self):
        # O(self.n * len(ar))
        store = np.zeros(self.n)
        index = np.zeros(self.n)
        for y in range(1, self.n+1):
            b = self.a + y * self.dx
            ar = np.zeros(self.N)
            for i in range(len(ar)):
                ar[i] = random.uniform(self.a, b)
            integral = 0.0 
            for i in ar:
                integral += self.f(i, b)
            store[y-1] = (b - self.a) / float(self.N) * integral
            index[y-1] = b
        return index, store

start = time.perf_counter()
"""Create MCIntergration object with given function, limits,..."""

integration = MCIntegration(f, 0, 1, 1000000, 0.001, 1000)

"""Calculation testing with b limit equals to 3. Expected answer is 4*sqrt(3)/gamma = 3.908820095"""

ans = integration.getIntegral()
expected = correctFunction(0.5)
print("The error is:", np.abs(expected - ans))
print(ans)

"""Get a set of 100 integration for plotting and compare with correct mathematics calculated function (4/3)*x^(3/2)/gamma"""

dataSet = integration.getDataset()

correct = correctFunction(dataSet[0])

"""Export caculated dataSet and correct dataSet to CSV File"""
name = "1"
export = np.transpose([dataSet[0], dataSet[1]])
np.savetxt("function" + name + ".csv", export, delimiter=",")

"""

Plot """
print(f"Finished in {time.perf_counter() - start: 5f} second(s)!")
